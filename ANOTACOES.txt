							CURSO DE SQL COM SQL SERVER BÓSON TREINAMENTOS

O SQL (Structured Query Language) é a linguagem padrão usada para interagir com bancos de dados relacionais, e o SQL Server é um dos sistemas de gerenciamento de banco de dados mais populares da Microsoft.

Passo 1: Criando uma Tabela
A criação de uma tabela é a primeira coisa que você faz ao configurar um banco de dados. Vamos criar uma tabela simples para armazenar informações de clientes:

CREATE TABLE Clientes (
    ClienteID INT PRIMARY KEY,       -- Identificador único para cada cliente
    Nome NVARCHAR(100),              -- Nome do cliente
    Email NVARCHAR(100),             -- E-mail do cliente
    DataNascimento DATE              -- Data de nascimento do cliente
);

Explicação:
CREATE TABLE: cria uma nova tabela no banco de dados.
INT: tipo de dado para números inteiros.
NVARCHAR(100): tipo de dado para texto (strings) com até 100 caracteres.
PRIMARY KEY: define que a coluna ClienteID será a chave primária, ou seja, cada valor nela deve ser único.

Passo 2: Inserindo Dados
Depois de criar a tabela, você pode inserir dados nela usando o comando INSERT INTO:
INSERT INTO Clientes (ClienteID, Nome, Email, DataNascimento)
VALUES (1, 'João Silva', 'joao.silva@email.com', '1990-05-15');

Explicação: INSERT INTO insere dados na tabela.
Os valores entre parênteses correspondem às colunas da tabela.

Passo 3: Consultando Dados
Agora, para consultar os dados que você inseriu na tabela, você usa o comando SELECT:
SELECT * FROM Clientes;

Explicação:SELECT *: seleciona todos os dados da tabela.
FROM Clientes: indica de qual tabela você quer buscar os dados.
Se você quiser consultar apenas alguns campos específicos, pode fazer assim:
SELECT Nome, Email FROM Clientes;

Passo 4: Atualizando Dados
Para atualizar dados existentes, você usa o comando UPDATE:
UPDATE Clientes
SET Email = 'novo.email@email.com'
WHERE ClienteID = 1;

Explicação:UPDATE: modifica dados existentes.
SET: define quais colunas e valores serão alterados.
WHERE: especifica quais linhas devem ser alteradas (se você não usar o WHERE, todos os registros serão atualizados).

Passo 5: Deletando Dados
Para excluir registros da tabela, você usa o comando DELETE:
DELETE FROM Clientes
WHERE ClienteID = 1;

Explicação: DELETE FROM: exclui dados de uma tabela.
WHERE: especifica qual registro deve ser excluído. Sem o WHERE, todos os registros seriam excluídos.

Passo 6: Filtrando Dados
Você pode filtrar dados usando a cláusula WHERE. Por exemplo, se você quiser ver todos os clientes que nasceram após 1º de janeiro de 1990:
SELECT * FROM Clientes
WHERE DataNascimento > '1990-01-01';

Passo 7: Ordenando Resultados
Para ordenar os resultados de uma consulta, você pode usar a cláusula ORDER BY:
SELECT * FROM Clientes
ORDER BY Nome ASC;  -- Ordena pelo nome em ordem crescente (ASC)

Se quiser ordenar em ordem decrescente (do Z ao A), pode usar DESC:
SELECT * FROM Clientes
ORDER BY Nome DESC;
_______________________________________________________________________________________________________________________________________________________________________

* RESTRIÇÕES DE COLUNA CONSTRAINT (CLÁUSULA CONSTRAINT)
- Restrições são regras pré-definidas impostas às colunas de uma tabela.
- Usadas para controlar os dados que são inseridos, em nível de coluna ou de tabela.
- Podem ser especificadas no momento de criação da tabela (CREATE) ou após a tabela ter sido criada (ALTER)

* Constraints no SQL Server:
- NOT NULL: Por padrão, o SQL Server permite armazenamento de valores nulos em colunas. A constraint NOT NULL impede que uma coluna aceite valores NULL. Deste modo, não é possível inserir um registro (ou atualizar) sem que haja um valor neste campo. Exemplo: Validade DATE NOT NULL
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- UNIQUE: Assegura que não haja valores duplicados em uma coluna ou combinação de colunas. Pode haver várias constraints UNIQUE em uma tabela, mas apenas uma Chave Primária por tabela. Uma constraint PRIMARY KEY automaticamente possui uma restrição UNIQUE definida. Exemplo: NomeProduto VARCHAR(50) NOT NULL UNIQUE
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- CHECK: Define um conjunto de valores válidos que podem ser inseridos em determinadas colunas. Se for definida em uma única coluna ela permitirá apenas determinados valores para a coluna. Usada para limitar os valores que podem ser colocados em uma coluna. Exemplo: PrecoProduto MONEY NOT NULL CHECK(PrecoProduto > 0)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- PRIMARY KEY: Uma chave primária identifica de forma única cada registro em uma tabela de banco de dados. A coluna não pode conter valores repetidos e nem valores NULL. Estabelece os relacionamentos entre tabelas. Cada tabela só pode ter uma única chave primária. Exemplo: CodProduto SMALLINT PRIMARY KEY
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- FOREIGN KEY: Cria relacionamentos entre tabelas, combinada com chaves primárias (relacionamento pai-filho). Cada registro em uma coluna de chave estrangeira da tabela-filha deve possuir um registro correspondente na chave primária (tabela-pai). Não pode possuir valores NULL. Impõe integridade referencial às tabelas.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- DEFAULT: Fornece um valor padrão para uma coluna. O valor padrão é inserido em uma coluna caso nenhum outro valor seja especificado durante a inserção de um novo registro. Usada para fornecer um valor padrão para uma coluna quando nenhum valor é especificado. Exemplo: CodFornecedor SMALLINT DEFAULT 1520
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

				
			* DEFRENÇAS ENTRE PRIMARY KEY e UNIQUE
+--------------------------+----------------------------------------------------------------+
|       Primary Key        |                          Unique                                |
+-------------------------+-----------------------------------------------------------------+
| Identifica cada linha de | Identifica valores únicos em uma coluna de uma tabela.         |
| forma única em uma       |                                                                |
| tabela.                  |                                                                |
+-------------------------+-----------------------------------------------------------------+
| Não podem haver valores  | Pode aceitar um valor NULL na coluna.                          |
| NULL.                    |                                                                |
+-------------------------+-----------------------------------------------------------------+
| Uma tabela somente pode  | Uma tabela pode ter mais de uma restrição unique.              |
| ter uma única chave      |                                                                |
| primária.                |                                                                |
+------------------------- +----------------------------------------------------------------+
| Um índice clusterizado   | Índices não-clusterizados são criados nas colunas.             |
| é criado por padrão.     |                                                                |
+-------------------------+---------------------------------------------------------------+

EXEMPLO DE CONSTRAINTS
CREATE TABLE Produtos(
   CodProduto SMALLINT PRIMARY KEY,
   NomeProduto VARCHAR(50) NOT NULL UNIQUE,
   CodFornecedor SMALLINT DEFAULT 1520,
   Validade DATE NOT NULL,
   PrecoProduto MONEY NOT NULL CHECK(PrecoProduto > 0),
   CONSTRAINT fk_id_fornecedor FOREIGN KEY (CodFornecedor) REFERENCES fornecedores (CodFornecedor) ON DELETE CASCADE
);

_______________________________________________________________________________________________________________________________________________________________________

* CRIAR TABELAS (CREATE TABLE): 
- Sintaxe básica:
CREATE TABLE NomeTabela(   
   coluna1 tipo1 restrições,
   coluna2 tipo2 restrições,

   ...

   colunaN tipo restrições,
   restrições adicionais
);

***OBS: Ao criar um banco de dados, devemos começar criando as tabelas que não têm campos dependentes de outras tabelas. Ou seja, crie primeiro as tabelas independentes, aquelas que não fazem referência a dados de outras tabelas.
- Primeiro criamos as tabelas que não tem chave estrangeira.
- Se possível sempre utilizar o menor tipo possível para economizar espaço no banco e em memória.
_______________________________________________________________________________________________________________________________________________________________________

* TIPOS DE DADOS
- char(n): String de caracteres e tamanho fixo n, máximo de 8000 caracteres.
- varchar(n): String de caracteres de tamanho variável n, máximo de 8000 caracteres.
- tinyint: Números inteiros de 0 a 255.
- smallint: Números inteiros de -32768 a 32767.
- int: Números inteiros entre -2, 147, 483, 648 e 2, 147, 483, 647.
- money: Dados monetários de -922.337.203.685.477,5808 até 922.337.203.685.477,5807.
- real: Números de ponto flutuante de precisão dupla entre -3,4 x 10³⁸ e 3,4 x 10³⁸.
- date: Data apenas. De 01/01/0001 a 31/12/9999.
- time: Hora apenas. Precisão de até 100 nanossegundos.

_______________________________________________________________________________________________________________________________________________________________________

OBS: Ao criar chaves estrangeiras, uma boa prática para facilitar o entendimento do relacionamento entre as tabelas no banco de dados é utilizar nomes de chaves estrangeiras que correspondam aos nomes dos IDs das tabelas relacionadas. Embora isso não seja uma obrigatoriedade, adotar essa convenção ajuda a tornar o esquema mais claro, pois torna explícito que a chave estrangeira faz referência à chave primária de outra tabela.
Além disso, os tipos de dados das chaves estrangeiras devem ser os mesmos ou compatíveis com os tipos de dados das chaves primárias das tabelas que possuem relacionamento. Isso garante a integridade referencial e melhora a performance do banco de dados.

Exemplo:
Vamos supor que temos duas tabelas: Clientes e Pedidos. Cada pedido deve estar associado a um cliente, então criamos uma chave estrangeira na tabela Pedidos que faz referência à chave primária da tabela Clientes.

1. Criação da Tabela Clientes:
CREATE TABLE Clientes (
    ClienteId INT PRIMARY KEY,  -- Chave primária da tabela Clientes
    Nome VARCHAR(100),
    Email VARCHAR(100)
);


2. Criação da Tabela Pedidos:
CREATE TABLE Pedidos (
    PedidoId INT PRIMARY KEY,  -- Chave primária da tabela Pedidos
    DataPedido DATE,
    ClienteId INT,  -- Chave estrangeira que referencia o ClienteId de Clientes
    FOREIGN KEY (ClienteId) REFERENCES Clientes(ClienteId)
);


Explicação sobre os tipos de dados:
Chave Primária (ClienteId em Clientes): A coluna ClienteId em Clientes é definida como INT, o que significa que ela pode armazenar valores inteiros.
Chave Estrangeira (ClienteId em Pedidos): A chave estrangeira ClienteId na tabela Pedidos também deve ser do tipo INT para garantir que ela seja compatível com a chave primária da tabela Clientes.
Ao utilizar o mesmo tipo de dados para a chave primária e a chave estrangeira, o banco de dados pode garantir que os valores armazenados em Pedidos.ClienteId correspondam corretamente aos valores em Clientes.ClienteId, assegurando a integridade referencial. Isso significa que um valor em Pedidos.ClienteId só pode ser inserido se já existir um correspondente valor em Clientes.ClienteId.

Importância de Usar Tipos de Dados Compatíveis:
Integridade Referencial: Quando os tipos de dados são os mesmos, o banco de dados pode garantir que os valores nas chaves estrangeiras sempre correspondam aos valores das chaves primárias. Caso contrário, você poderia inserir um valor incompatível, violando o relacionamento.

Desempenho: O banco de dados pode otimizar buscas e comparações de valores quando as colunas de relacionamento têm tipos de dados compatíveis. Isso melhora a performance em consultas e operações de junção (JOIN).

Exemplo de erro se os tipos de dados não forem compatíveis:
Se, por exemplo, a chave primária ClienteId fosse definida como BIGINT na tabela Clientes, mas a chave estrangeira na tabela Pedidos fosse definida como INT, o banco de dados geraria um erro de incompatibilidade de tipos quando tentasse associar as duas tabelas. Para corrigir, seria necessário ajustar o tipo de dados da chave estrangeira para BIGINT.

Conclusão:
Nomes Consistentes: Utilizar o mesmo nome para a chave primária e a chave estrangeira, como ClienteId em ambos os casos, facilita o entendimento de que há uma relação entre as tabelas.
Tipos de Dados Compatíveis: É importante que as chaves primárias e estrangeiras tenham tipos de dados compatíveis (por exemplo, ambos INT ou ambos BIGINT) para garantir a integridade referencial e desempenho eficiente nas operações do banco de dados.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*SINTAXE PARA CRIAÇÃODE CHAVE ESTRANGEIRA:
Sintaxe geral
Aqui está a estrutura básica para adicionar uma chave estrangeira em SQL:

CONSTRAINT nome_da_restricao FOREIGN KEY (campo_da_tabela_atual)
REFERENCES tabela_referenciada(campo_referenciado)
[ON DELETE CASCADE] [ON UPDATE CASCADE];

------------------------------------------------------------------------------------------------------------------------------------------------------------------------Explicando o exemplo:

- CONSTRAINT nome_da_restricao: Define o nome da restrição (restrição de chave estrangeira).

- FOREIGN KEY (campo_da_tabela_atual): Especifica o campo da tabela atual que se tornará a chave estrangeira.

- REFERENCES tabela_referenciada(campo_referenciado): Indica qual é a tabela de referência (que já tem a chave primária) e o campo que é a chave primária nessa tabela.

- ON DELETE CASCADE (opcional): Define o que deve acontecer quando um registro na tabela referenciada for excluído. "CASCADE" significa que todos os registros dependentes (da tabela atual) também serão excluídos automaticamente.

- ON UPDATE CASCADE (opcional): Define o que deve acontecer quando um valor na chave primária da tabela referenciada for atualizado. "CASCADE" significa que os valores correspondentes nas tabelas dependentes também serão atualizados automaticamente.

_______________________________________________________________________________________________________________________________________________________________________
O QUE É UMA TABELA ASSOCIATIVA?
Uma tabela associativa (ou de relacionamento) é utilizada para estabelecer um relacionamento muitos-para-muitos entre duas outras tabelas. No caso, a tabela LivroAutor está relacionando os livros com seus autores, permitindo que um livro tenha vários autores e um autor possa escrever vários livros.

No caso do seu código:

-- Tabela associativa que armazena os relacionamentos entre livros e autores
CREATE TABLE LivroAutor (
    IdLivro SMALLINT NOT NULL,  -- Referência à tabela Livro
    IdAutor SMALLINT NOT NULL,  -- Referência à tabela Autor
    CONSTRAINT fk_id_livros FOREIGN KEY(IdLivro) REFERENCES Livro(IdLivro),
    CONSTRAINT fk_id_Autor FOREIGN KEY(IdAutor) REFERENCES Autor(IdAutor)
);

_______________________________________________________________________________________________________________________________________________________________________

* GERENCIAMENTO TABELAS - ALTER, DROP, RENAME: No SQL Server, o gerenciamento de tabelas envolve a utilização de comandos para modificar a estrutura das tabelas no banco de dados. Os comandos ALTER, DROP e RENAME são utilizados para realizar essas modificações. Vamos explicar cada um deles:

1. ALTER TABLE
O comando ALTER TABLE é usado para modificar a estrutura de uma tabela existente. Ele permite que você adicione, exclua ou altere colunas de uma tabela. Aqui estão alguns exemplos:

Adicionar uma nova coluna:
ALTER TABLE nome_da_tabela
ADD nova_coluna tipo_de_dado;

Exemplo:
ALTER TABLE Funcionarios
ADD DataDeNascimento DATE;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Modificar uma coluna existente:
ALTER TABLE nome_da_tabela
ALTER COLUMN nome_da_coluna novo_tipo_de_dado;

Exemplo:
ALTER TABLE Funcionarios
ALTER COLUMN Salario DECIMAL(10, 2);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Excluir uma coluna:
ALTER TABLE nome_da_tabela
DROP COLUMN nome_da_coluna;

Exemplo:
ALTER TABLE Funcionarios
DROP COLUMN DataDeNascimento;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. DROP TABLE
O comando DROP TABLE é utilizado para excluir completamente uma tabela do banco de dados, junto com todos os dados nela contidos. Tenha muito cuidado ao usar esse comando, pois ele é irreversível.
DROP TABLE nome_da_tabela;

Exemplo:
DROP TABLE Funcionarios;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. RENAME (ALTER TABLE para renomear)
No SQL Server, o comando RENAME não é diretamente suportado. Para renomear uma tabela, você usa o comando sp_rename. Este procedimento armazenado é utilizado para alterar o nome de objetos no banco de dados, como tabelas, colunas, índices, etc.

Para renomear uma tabela:
EXEC sp_rename 'nome_antigo_da_tabela', 'novo_nome_da_tabela';

Exemplo:
EXEC sp_rename 'Funcionarios', 'Empregados';
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Para renomear uma coluna:
EXEC sp_rename 'nome_da_tabela.nome_da_coluna', 'novo_nome_da_coluna', 'COLUMN';

Exemplo:
EXEC sp_rename 'Empregados.Salario', 'Rendimento', 'COLUMN';
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Resumo:
ALTER TABLE: Modifica a estrutura da tabela, como adicionar, excluir ou alterar colunas.
DROP TABLE: Exclui a tabela e seus dados permanentemente.
RENAME: No SQL Server, usa-se sp_rename para renomear tabelas e colunas.

_______________________________________________________________________________________________________________________________________________________________________

Complementos sobre o código e os comandos:
1. Adicionando uma chave primária
Quando você usa o comando ALTER TABLE para adicionar uma chave primária à tabela, é importante observar que ela só pode ser adicionada se a tabela não tiver uma chave primária definida previamente.

Exemplo de código:
ALTER TABLE NomeTabela
ADD PRIMARY KEY (Coluna);

Isso cria uma chave primária na coluna especificada, garantindo que os valores nesta coluna sejam únicos e não nulos.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Excluir uma constraint de uma coluna
As constraints (restrições) em SQL são usadas para impor regras sobre os dados em uma tabela, como PRIMARY KEY, FOREIGN KEY, CHECK, UNIQUE, etc. Para remover uma constraint de uma tabela, você deve usar o comando DROP CONSTRAINT.

Exemplo:
ALTER TABLE NomeTabela
DROP CONSTRAINT NomeConstraint;
Isso remove a constraint especificada, que pode ser, por exemplo, uma chave primária ou uma chave estrangeira.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Verificar o nome das constraints de uma tabela
Você pode usar o procedimento armazenado sp_help para listar todas as propriedades de uma tabela, incluindo as constraints associadas a ela. Isso pode ser útil para saber quais constraints você pode querer alterar ou remover.

Exemplo:
sp_help Livro;
Este comando retornará uma série de informações sobre a tabela Livro, incluindo as constraints que ela possui.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Exclusão de coluna
Ao excluir uma coluna, é importante lembrar que todos os dados daquela coluna serão apagados. O comando ALTER TABLE ... DROP COLUMN permite remover uma coluna específica de uma tabela.

Exemplo:
ALTER TABLE Livro
DROP COLUMN Edição;
Este comando remove a coluna Edição da tabela Livro.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Resumo do código complementado:
Adicionar uma nova coluna: Usa-se ALTER TABLE seguido de ADD para adicionar uma coluna a uma tabela existente.

Alterar tipo de dado de uma coluna: Com o ALTER COLUMN, é possível modificar o tipo de dado de uma coluna existente.

Adicionar uma chave primária: Você pode definir uma chave primária com ADD PRIMARY KEY, desde que a tabela não tenha uma chave primária existente.

Remover uma constraint: Para excluir uma constraint, usa-se o comando DROP CONSTRAINT.

Verificar informações sobre a tabela e constraints: A função sp_help fornece detalhes sobre as propriedades de uma tabela, incluindo suas constraints.

Excluir uma coluna de uma tabela: Utiliza-se DROP COLUMN para remover uma coluna de uma tabela.

Excluir uma tabela: Com o comando DROP TABLE, a tabela inteira é excluída permanentemente.

Esses detalhes adicionais ajudam a fornecer uma visão mais completa do gerenciamento de tabelas no SQL Server, especialmente quando se trata de manipulação de constraints e chaves.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Renomear objetos no SQL Server (usando sp_rename)
No SQL Server, não existe um comando direto chamado RENAME como em alguns outros SGBDs (Sistema de Gerenciamento de Banco de Dados). Em vez disso, para renomear tabelas, colunas, índices, e outros objetos do banco de dados, usamos o procedimento armazenado sp_rename.

Sintaxe básica:
EXEC sp_rename 'nome_atual', 'novo_nome';
Esse comando pode ser usado para renomear tabelas, colunas, e até índices.

Exemplos práticos de uso de sp_rename:
1. Renomear uma tabela
Se você quiser alterar o nome de uma tabela, basta fornecer o nome atual e o novo nome desejado.

Exemplo:
EXEC sp_rename 'Livro', 'Livros';
Isso renomeia a tabela Livro para Livros.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Renomear uma coluna
Para renomear uma coluna de uma tabela, a sintaxe é ligeiramente diferente. Você precisa especificar o nome da tabela, o nome da coluna que você quer renomear, e o novo nome da coluna.

Exemplo:
EXEC sp_rename 'Livros.Edição', 'Versao', 'COLUMN';
Aqui, a coluna Edição da tabela Livros é renomeada para Versao.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. Renomear um índice
Da mesma forma, você pode usar o sp_rename para alterar o nome de um índice.

Exemplo:
EXEC sp_rename 'Livros.Index_Edicao', 'Index_Versao', 'INDEX';
Isso renomeia o índice Index_Edicao para Index_Versao na tabela Livros.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Considerações importantes:
Necessidade de permissões: Para usar o sp_rename, o usuário precisa ter permissões adequadas no banco de dados, como permissão de ALTER em tabelas ou objetos a serem renomeados.

Impacto nas dependências: Renomear objetos, como tabelas ou colunas, pode afetar dependências (como views, stored procedures, triggers, etc.) que referenciam esses objetos. É importante revisar essas dependências e atualizá-las conforme necessário após renomear.

Limitações do sp_rename:

O sp_rename não pode ser utilizado para renomear objetos do tipo constraint diretamente. Para isso, é necessário excluir a constraint e criar uma nova.
Não é possível renomear uma chave primária ou chave estrangeira diretamente; é necessário removê-las e criá-las novamente com o novo nome.

Resumo:
No SQL Server, o comando RENAME é substituído pelo procedimento armazenado sp_rename.
sp_rename pode ser usado para renomear tabelas, colunas, índices e outros objetos.
Ao usar sp_rename, sempre esteja atento às dependências do objeto renomeado para evitar problemas no banco de dados.
Agora, o conjunto completo de operações sobre gerenciamento de tabelas fica assim:

ALTER TABLE: Modifica a estrutura de tabelas, como adicionar ou excluir colunas, alterar tipos de dados, ou adicionar/remover constraints.
DROP TABLE: Exclui completamente uma tabela e seus dados.
RENAME (via sp_rename): Renomeia tabelas, colunas, índices e outros objetos no banco de dados.
_______________________________________________________________________________________________________________________________________________________________________

* CADASTRAR DADOS - INSERT INTO(Inserir Dados): Inserir um registro(linha) em uma tabela.
Sintaxe:
INSERT INTO tabela(coluna1, coluna2, ...) VALUES(valor1, valor2, ...);
_______________________________________________________________________________________________________________________________________________________________________

**OBS: Na hora de inserir os dados nas tabelas, deve-se primeiramente inserir os dados nas tabelas que não dependem de nenhuma outra, ou seja que não tenha chave estrangeira.
_______________________________________________________________________________________________________________________________________________________________________

* CONSULTAS SIMPLES SELECT FROM: 

Consulta SELECT e SELECT INTO no SQL Server

1. Comando SELECT
O comando SELECT é utilizado para recuperar dados de uma ou mais tabelas no banco de dados. Ele permite especificar as colunas a serem recuperadas, a tabela de origem dos dados e aplicar filtros para refinar os resultados.

Sintaxe básica do SELECT:
SELECT coluna1, coluna2, ...
FROM tabela
WHERE condição;

- SELECT: Especifica as colunas a serem retornadas.
- FROM: Define a tabela de onde os dados serão extraídos.
- WHERE (opcional): Aplica um filtro para limitar os resultados com base em uma condição.

Exemplos de uso do SELECT:
Selecionar todas as colunas de uma tabela:
SELECT * FROM clientes;
Retorna todos os dados da tabela clientes.

Selecionar colunas específicas:
SELECT nome, idade FROM clientes;
Retorna as colunas nome e idade da tabela clientes.

Usar filtro com WHERE:
SELECT nome, idade FROM clientes WHERE idade > 18;
Retorna os nomes e idades dos clientes com mais de 18 anos.

2. Comando SELECT INTO
O SELECT INTO é usado para criar uma nova tabela e inserir nela os dados retornados por uma consulta SELECT. Isso é útil quando você quer criar uma cópia de dados ou criar uma tabela com base nos resultados de uma consulta, sem precisar criar a tabela manualmente.

Sintaxe básica do SELECT INTO:
SELECT coluna1, coluna2, ...
INTO nova_tabela
FROM tabela_existente
WHERE condição;

- SELECT: Especifica as colunas a serem selecionadas.
- INTO: Define a criação da nova tabela onde os dados serão inseridos.
- nova_tabela: Nome da nova tabela que será criada automaticamente.
- FROM: A tabela de onde os dados serão retirados.
- WHERE (opcional): Aplica uma condição para filtrar os dados a serem copiados.

Exemplos de uso do SELECT INTO:
Criar uma nova tabela e copiar dados: Se você quiser criar uma tabela novos_clientes com os clientes acima de 18 anos, pode usar o seguinte comando:
SELECT nome, idade, cidade
INTO novos_clientes
FROM clientes
WHERE idade > 18;

Isso cria a tabela novos_clientes com as colunas nome, idade e cidade, contendo apenas os dados dos clientes com idade superior a 18.

Criar uma tabela de backup: Para criar uma tabela de backup com todos os dados de uma tabela clientes, você pode fazer:
SELECT *
INTO backup_clientes
FROM clientes;

Isso cria a tabela backup_clientes com todos os dados da tabela clientes.

Diferenças chave entre SELECT e SELECT INTO:

SELECT: Apenas recupera dados de uma tabela existente, sem criar uma nova tabela.
SELECT INTO: Cria uma nova tabela (caso não exista) e insere nela os dados retornados pela consulta SELECT.
Considerações importantes sobre o SELECT INTO:
A nova tabela criada com o SELECT INTO terá a mesma estrutura (colunas e tipos de dados) dos dados selecionados, mas não herda as constraints (como chaves primárias ou índices).
Não pode ser usada se a tabela de destino já existir. Se você precisar inserir dados em uma tabela existente, deve usar o comando INSERT INTO.
Com esses dois comandos, você pode realizar consultas simples e também criar novas tabelas de maneira prática com base nos dados que já existem no seu banco de dados!
_______________________________________________________________________________________________________________________________________________________________________

* ORDENAÇÃO DE RESULTADOS EM CONSULTAS SQL - Cláusula ORDER BY:
A cláusula ORDER BY no SQL Server é usada para ordenar os resultados de uma consulta SQL. Ela organiza os dados retornados em uma ordem crescente ou decrescente com base em uma ou mais colunas. O comportamento da cláusula ORDER BY pode ser ajustado conforme a necessidade de exibir os dados de forma ordenada de acordo com as regras estabelecidas.

Sintaxe Básica:
SELECT coluna1, coluna2, ...
FROM tabela
ORDER BY coluna1 [ASC|DESC], coluna2 [ASC|DESC], ...;

- coluna1, coluna2, ...: São os nomes das colunas que você deseja selecionar.
- tabela: É a tabela de onde os dados serão recuperados.
- ORDER BY: A palavra-chave que indica que os resultados devem ser ordenados.
- coluna1, coluna2, ...: São as colunas pelas quais você deseja ordenar os resultados.
- ASC (opcional): Ordena os dados em ordem crescente (valor padrão).
- DESC (opcional): Ordena os dados em ordem decrescente.

Como funciona:
Ordem Crescente (ASC): Quando você usa ASC ou omite o tipo de ordenação (pois o padrão é crescente), os dados serão ordenados da menor para a maior (ex: números de menor para maior, datas mais antigas para mais recentes, textos em ordem alfabética crescente).

Exemplo:
SELECT nome, idade
FROM pessoas
ORDER BY idade ASC;  //Isso ordenará as pessoas pela idade de forma crescente.



Ordem Decrescente (DESC): Quando você usa DESC, os dados serão ordenados da maior para a menor (ex: números de maior para menor, datas mais recentes para mais antigas, textos em ordem alfabética inversa).

Exemplo:
SELECT nome, idade
FROM pessoas
ORDER BY idade DESC;  //Isso ordenará as pessoas pela idade de forma decrescente.


Exemplos práticos:
Ordenando por uma coluna:

- Se você quiser ordenar os resultados por uma única coluna, por exemplo, pelo nome em ordem alfabética crescente:
SELECT nome, salario
FROM funcionarios
ORDER BY nome;

Ordenando por múltiplas colunas: Caso você queira ordenar por várias colunas, a ordem será feita primeiro pela coluna 1 e, em seguida, pela coluna 2 (se houver empates na coluna 1).

Exemplo:
SELECT nome, idade, salario
FROM pessoas
ORDER BY idade DESC, salario ASC;

Neste caso, as pessoas serão ordenadas por idade de forma decrescente. Se houver empates na idade, os salários serão usados para ordenar de forma crescente.

Combinando tipos de ordenação: Você também pode misturar ASC e DESC para diferentes colunas:
SELECT produto, preco, data_lancamento
FROM produtos
ORDER BY preco DESC, data_lancamento ASC;

Neste exemplo, os produtos são ordenados pelo preço em ordem decrescente e, em caso de empate no preço, a ordenação será feita pela data de lançamento em ordem crescente.

Observações:
ORDER BY sempre deve ser a última cláusula na consulta SQL.
Se você não especificar o tipo de ordenação (ASC ou DESC), o SQL Server considerará ASC como padrão.
Você pode ordenar por qualquer expressão ou função (como YEAR(data_lancamento)) ou até mesmo por índices calculados nas colunas.

Importância do ORDER BY:
Ordenar resultados ajuda a facilitar a análise e a leitura dos dados.
É útil em relatórios onde a ordem dos dados é crucial, como listas de produtos, salários, classificações, etc.
_______________________________________________________________________________________________________________________________________________________________________

* RESTRIÇÃO DE RESULTADOS - SELECT TOP: 
A cláusula SELECT TOP no SQL Server é usada para limitar o número de resultados retornados por uma consulta. Ela permite especificar um número fixo de registros ou uma porcentagem dos registros que você deseja recuperar de uma tabela.

A principal função da cláusula TOP é controlar o volume de dados retornado pela consulta, especialmente útil quando você precisa apenas de um subconjunto dos resultados, como os primeiros "n" registros, ou quando está lidando com grandes volumes de dados.

Sintaxe Básica:
SELECT TOP (n) coluna1, coluna2, ...
FROM tabela;

- n: O número de registros a serem retornados. Pode ser um valor fixo ou uma porcentagem.
- coluna1, coluna2, ...: São as colunas que você deseja selecionar.
- tabela: A tabela de onde você deseja recuperar os dados.

Exemplos de uso:
1- Retornar os primeiros N registros: Se você quiser recuperar os 10 primeiros livros da tabela Livro, pode usar a seguinte consulta:
SELECT TOP 10 NomeLivro, PreçoLivro
FROM Livro;

Este comando retornará os 10 primeiros livros da tabela Livro. A ordem dos registros pode ser aleatória, a menos que você use a cláusula ORDER BY para especificar uma ordem.

2- Limitar os resultados com base em uma condição ordenada: Caso você queira os 5 livros mais caros (por exemplo), pode usar a cláusula ORDER BY para ordenar os dados antes de aplicar o TOP:
SELECT TOP 5 NomeLivro, PreçoLivro
FROM Livro
ORDER BY PreçoLivro DESC;

Isso retornará os 5 livros com os maiores preços, ordenados de forma decrescente.


3- Usando uma porcentagem para limitar os resultados: Se você quiser recuperar 10% dos livros mais baratos, pode usar a cláusula PERCENT:
SELECT TOP 10 PERCENT NomeLivro, PreçoLivro
FROM Livro
ORDER BY PreçoLivro ASC;

Isso retornará 10% dos livros mais baratos da tabela Livro, ordenados de forma crescente pelo preço.

4- Usando TOP com outras cláusulas: O TOP pode ser combinado com outras cláusulas para refinar ainda mais os resultados. Por exemplo, para encontrar os 10 livros mais baratos de uma determinada editora:
SELECT TOP 10 NomeLivro, PreçoLivro
FROM Livro
WHERE IdEditora = 2
ORDER BY PreçoLivro ASC;

Este comando retorna os 10 livros mais baratos da editora com IdEditora = 2, ordenados pelo preço.

Como o TOP funciona:
- Sem ORDER BY: Quando você não usa ORDER BY, a consulta retorna os primeiros registros que o SQL Server encontrar. Isso pode ser imprevisível, já que o banco de dados pode retornar os registros em qualquer ordem.
- Com ORDER BY: Quando você usa ORDER BY, a consulta irá ordenar os dados antes de aplicar a restrição do TOP, garantindo que os registros retornados estejam na ordem especificada.

Observações:
- A cláusula TOP pode ser usada com números absolutos ou porcentagens.
- O TOP é útil para consultas de desempenho, especialmente quando se trabalha com grandes volumes de dados, já que você pode evitar o processamento de grandes quantidades de informações.

- Importante: Sem o uso de ORDER BY, o SQL Server pode retornar resultados não previsíveis, pois o banco de dados não garante uma ordem específica sem essa cláusula.
Exemplo de uma aplicação prática:
Imagine que você tenha uma tabela de produtos com milhares de registros e deseja encontrar os 5 produtos mais vendidos. Você pode usar a consulta:
SELECT TOP 5 NomeProduto, QuantidadeVendida
FROM Produtos
ORDER BY QuantidadeVendida DESC;
Isso traria os 5 produtos com as maiores quantidades vendidas.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* WITH TIES: A cláusula WITH TIES é usada em conjunto com a cláusula TOP no SQL Server para garantir que, quando houver empates no valor da coluna ordenada, os registros empatados também sejam incluídos na consulta, mesmo que isso faça com que o número total de registros retornados seja maior do que o especificado pelo TOP.

Em outras palavras, WITH TIES permite que a consulta retorne mais registros do que o número indicado no TOP, caso haja empates na ordenação.

Sintaxe com WITH TIES:
sql
Copiar
SELECT TOP (n) WITH TIES coluna1, coluna2, ...
FROM tabela
ORDER BY colunaOrdenada;
n: O número de registros que você deseja recuperar, mas com a possibilidade de retornar mais registros se houver empates.
WITH TIES: Indica que você quer incluir todos os registros empatados com o valor da última linha incluída.
colunaOrdenada: A coluna pela qual os dados serão ordenados.
Como funciona:
Sem o WITH TIES, se você solicitar, por exemplo, os 10 primeiros registros ordenados por uma coluna (como preço ou data), e houver empates na 10ª posição, o SQL Server retornará somente 10 registros, excluindo os empatados.

Com WITH TIES, se a 10ª linha tiver um empate em algum valor (por exemplo, o mesmo preço ou data), todos os registros empatados com esse valor também serão retornados, mesmo que isso resulte em mais do que os 10 registros originais solicitados.

Exemplos de uso do WITH TIES:
Retornando os 5 livros mais baratos, incluindo empates:

Suponha que você queira pegar os 5 livros mais baratos da tabela Livro, mas se o preço do 5º livro for igual a outros, você também quer que esses livros empatados apareçam na consulta:

sql
Copiar
SELECT TOP 5 WITH TIES NomeLivro, PreçoLivro
FROM Livro
ORDER BY PreçoLivro ASC;
Se houver mais de 5 livros com o mesmo preço que o 5º livro mais barato, todos esses livros empatados serão incluídos na consulta.
Portanto, se houver, por exemplo, 8 livros com o mesmo preço na 5ª posição, a consulta retornará 8 livros ao invés de 5.
Exemplo com empates em ordenação decrescente:

Se você quiser pegar os 3 livros mais caros da tabela Livro, mas também incluir todos os livros que tenham o mesmo preço que o 3º livro mais caro:

sql
Copiar
SELECT TOP 3 WITH TIES NomeLivro, PreçoLivro
FROM Livro
ORDER BY PreçoLivro DESC;
Nesse caso, os livros mais caros são ordenados de forma decrescente, e caso haja empates na 3ª posição (por exemplo, vários livros com o mesmo preço), todos esses livros empatados também serão retornados.
Diferença entre TOP e TOP WITH TIES:
TOP: Limita exatamente o número de registros especificado. Exemplo: SELECT TOP 5 ... retornará exatamente 5 registros.
TOP WITH TIES: Retorna mais registros se houver empates na última posição especificada. Exemplo: SELECT TOP 5 WITH TIES ... pode retornar mais de 5 registros se houver empates na 5ª posição.
Exemplos de uso prático:
Suponha que você tenha a tabela Vendas com as colunas Produto e QuantidadeVendida e deseja listar os 10 produtos mais vendidos, incluindo os produtos que tenham o mesmo número de vendas que o 10º mais vendido.

Usando TOP sem WITH TIES:

sql
Copiar
SELECT TOP 10 Produto, QuantidadeVendida
FROM Vendas
ORDER BY QuantidadeVendida DESC;
Esse código retornará apenas 10 produtos, com as maiores quantidades vendidas. Se houver mais produtos com a mesma quantidade de vendas que o 10º, eles não serão retornados.

Usando TOP WITH TIES:

sql
Copiar
SELECT TOP 10 WITH TIES Produto, QuantidadeVendida
FROM Vendas
ORDER BY QuantidadeVendida DESC;
Nesse caso, o código retornará todos os produtos com as maiores quantidades vendidas, incluindo aqueles que tiverem a mesma quantidade de vendas que o 10º produto, possivelmente resultando em mais de 10 registros.

Observações importantes:
O uso de WITH TIES é especialmente útil quando você precisa garantir que todos os registros com valores empatados sejam incluídos, como em relatórios de rankings, vendas ou qualquer situação em que empates sejam relevantes.
WITH TIES deve ser acompanhado de uma cláusula ORDER BY, pois o emparelhamento e ordenação dos registros depende da ordenação.
Resumo:
SELECT TOP n: Limita a consulta aos n primeiros registros.
WITH TIES: Inclui todos os registros que tenham o mesmo valor da última linha retornada (quando houver empates), mesmo que isso faça o número total de registros ser maior que o especificado.
_______________________________________________________________________________________________________________________________________________________________________

* CONSULTAS: FILTROS- CLÁUSULA WHERE: A cláusula WHERE é usada em consultas SQL para filtrar registros que atendem a uma condição específica. Ela permite que você selecione apenas as linhas que atendem a um critério determinado, ajudando a refinar os resultados da consulta.

Sintaxe básica da cláusula WHERE:
sql
Copiar
SELECT coluna1, coluna2, ...
FROM tabela
WHERE condição;
Componentes principais:
coluna1, coluna2, ...: São as colunas que você deseja selecionar.
tabela: A tabela de onde os dados serão extraídos.
condição: A condição que deve ser atendida pelos registros para que sejam retornados na consulta.
Exemplo básico:
sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro > 100.00;
Neste exemplo, estamos selecionando NomeLivro e PreçoLivro da tabela Livro, mas apenas os livros cujo preço é maior que 100.00.
Como funciona a cláusula WHERE:
A WHERE permite especificar condições de filtragem com base em operadores e valores. As condições podem ser simples ou complexas, utilizando uma variedade de operadores.

Principais operadores usados na cláusula WHERE:
Operadores de comparação:

= (igual)
!= ou <> (diferente)
> (maior que)
< (menor que)
>= (maior ou igual a)
<= (menor ou igual a)
Exemplo:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro >= 50.00;
Operadores lógicos:

AND: Usado para combinar várias condições. Todos os critérios precisam ser verdadeiros.
OR: Usado para combinar várias condições. Pelo menos uma das condições precisa ser verdadeira.
NOT: Negação de uma condição.
Exemplo:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro > 50.00 AND PreçoLivro < 100.00;
Ou:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro < 50.00 OR PreçoLivro > 200.00;
Operadores de correspondência:

LIKE: Usado para comparar strings, permitindo o uso de wildcards (caracteres curinga). O % representa qualquer sequência de caracteres, e o _ representa um único caractere.

Exemplo:

sql
Copiar
SELECT NomeLivro
FROM Livro
WHERE NomeLivro LIKE 'A%';
Isso retornará todos os livros cujo nome começa com a letra "A".

BETWEEN: Usado para filtrar valores dentro de um intervalo especificado.

Exemplo:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro BETWEEN 50.00 AND 100.00;
IN: Usado para especificar uma lista de valores possíveis.

Exemplo:

sql
Copiar
SELECT NomeLivro
FROM Livro
WHERE IdAssunto IN (1, 2, 3);
Operadores de valor nulo:

IS NULL: Usado para verificar se um campo tem valor nulo.

IS NOT NULL: Usado para verificar se um campo não é nulo.

Exemplo:

sql
Copiar
SELECT NomeLivro
FROM Livro
WHERE PreçoLivro IS NOT NULL;
Exemplos adicionais:
Filtrando por um valor específico:

sql
Copiar
SELECT NomeLivro
FROM Livro
WHERE IdLivro = 1;
Retorna o livro cujo IdLivro é igual a 1.

Filtrando por valor maior que:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro > 200.00;
Retorna os livros cujo PreçoLivro é maior que 200.00.

Filtrando por múltiplas condições com AND:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro > 100.00 AND IdAssunto = 2;
Retorna os livros que custam mais de 100.00 e têm o IdAssunto igual a 2.

Filtrando por valores dentro de um intervalo com BETWEEN:

sql
Copiar
SELECT NomeLivro, PreçoLivro
FROM Livro
WHERE PreçoLivro BETWEEN 50.00 AND 150.00;
Retorna livros cujo preço está entre 50.00 e 150.00.

Filtrando por padrão de string com LIKE:

sql
Copiar
SELECT NomeLivro
FROM Livro
WHERE NomeLivro LIKE '%Python%';
Retorna livros cujo nome contém a palavra "Python".

Filtrando por valores específicos com IN:

sql
Copiar
SELECT NomeLivro
FROM Livro
WHERE IdAssunto IN (1, 3, 5);
Retorna livros cujos IdAssunto são 1, 3 ou 5.

Considerações importantes sobre a cláusula WHERE:
Case Sensitivity: Em algumas bases de dados, as comparações podem ser case-sensitive (sensíveis a maiúsculas e minúsculas). Isso depende da configuração do banco de dados. No SQL Server, por exemplo, comparações de strings podem ser sensíveis a maiúsculas/minúsculas, dependendo da collation do banco.
Nulos: Ao trabalhar com valores nulos, lembre-se de usar IS NULL ou IS NOT NULL, porque comparações como = NULL não funcionam corretamente.
Resumo:
A cláusula WHERE é uma das partes mais importantes em consultas SQL. Ela permite filtrar registros com base em condições específicas, utilizando operadores de comparação, lógicos, correspondência, e valor nulo. Ela é essencial para refinar a seleção de dados e retornar apenas os registros relevantes para a consulta.
_______________________________________________________________________________________________________________________________________________________________________

* EXCLUIR LINHAS - DELETE FROM: O comando DELETE FROM no SQL Server é utilizado para excluir registros (linhas) de uma tabela específica. O comportamento básico desse comando é o seguinte:

Sintaxe Básica:
DELETE FROM nome_da_tabela WHERE condição;

- nome_da_tabela: o nome da tabela da qual você deseja excluir as linhas.
- condição: uma cláusula WHERE opcional, que especifica quais registros serão excluídos. Se a condição for omitida, todas as linhas da tabela serão excluídas.

Exemplo:
DELETE FROM Funcionarios WHERE Cargo = 'Estagiário';
Esse comando excluirá todos os registros da tabela Funcionarios onde o campo Cargo for igual a 'Estagiário'.

* Comportamento com Tabelas com IDENTITY:
Se a tabela tem uma coluna com a propriedade IDENTITY, que gera valores únicos automaticamente (normalmente usada para campos como ID), o comportamento do comando DELETE FROM não afeta diretamente a sequência de valores gerados por essa coluna. Ou seja, ao excluir uma linha, o valor gerado pelo IDENTITY não será reatribuído ou "reutilizado" por novas inserções. A sequência do campo IDENTITY continua a incrementar normalmente.

Exemplo:
Se a tabela Funcionarios tem um campo ID configurado como IDENTITY e você exclui um registro:
1- Suponha que você tenha inserido 5 registros com os IDs: 1, 2, 3, 4 e 5.
2- Ao executar DELETE FROM Funcionarios WHERE ID = 3;, o registro com o ID = 3 será excluído, mas o próximo registro inserido terá um ID gerado como 6, não reutilizando o valor 3.
Esse comportamento é importante para garantir a integridade dos dados e o uso correto de valores exclusivos na coluna IDENTITY.

Observação Importante:
Restauração do Auto Incremento: Caso você queira redefinir o valor do IDENTITY após excluir registros (por exemplo, para reiniciar a numeração ou reatribuir os valores dos IDs), você pode usar o comando DBCC CHECKIDENT. Um exemplo de como fazer isso:
DBCC CHECKIDENT ('Funcionarios', RESEED, 0);
Isso fará com que o próximo valor gerado para a coluna IDENTITY seja 1 (ou qualquer valor definido no RESEED).

Em resumo, o comando DELETE FROM no SQL Server exclui registros da tabela, mas não interfere diretamente no comportamento da coluna IDENTITY. Para "resetar" ou ajustar a sequência do IDENTITY, você precisaria de comandos adicionais como DBCC CHECKIDENT.    

OBS 1: Nunca execute o comando DELETE FROM sem uma cláusula WHERE, pois, caso contrário, todos os dados da tabela serão excluídos (ou seja, todos os registros serão apagados, sem exceção)e ainda por cima sem zeraro identity. Certifique-se de usar a cláusula WHERE para especificar quais registros devem ser removidos.

OBS 2: O comando DELETE FROM não altera o valor do identity (a coluna com incremento automático de valores). Isso significa que, se a tabela contiver uma coluna com identity, os valores dessa coluna continuarão a partir do último número gerado e não serão resetados para o valor inicial. Portanto, se perceber que os valores dessa coluna começam a "pular" (ex: 1, 2, 3, 10, 11...), não se preocupe, isso é normal. No entanto, caso deseje resetar o valor do identity (fazendo ele começar novamente do valor inicial), é possível fazer isso, se necessário.





























