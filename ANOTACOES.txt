							CURSO DE SQL COM SQL SERVER BÓSON TREINAMENTOS

O SQL (Structured Query Language) é a linguagem padrão usada para interagir com bancos de dados relacionais, e o SQL Server é um dos sistemas de gerenciamento de banco de dados mais populares da Microsoft.

Passo 1: Criando uma Tabela
A criação de uma tabela é a primeira coisa que você faz ao configurar um banco de dados. Vamos criar uma tabela simples para armazenar informações de clientes:

CREATE TABLE Clientes (
    ClienteID INT PRIMARY KEY,       -- Identificador único para cada cliente
    Nome NVARCHAR(100),              -- Nome do cliente
    Email NVARCHAR(100),             -- E-mail do cliente
    DataNascimento DATE              -- Data de nascimento do cliente
);

Explicação:
CREATE TABLE: cria uma nova tabela no banco de dados.
INT: tipo de dado para números inteiros.
NVARCHAR(100): tipo de dado para texto (strings) com até 100 caracteres.
PRIMARY KEY: define que a coluna ClienteID será a chave primária, ou seja, cada valor nela deve ser único.

Passo 2: Inserindo Dados
Depois de criar a tabela, você pode inserir dados nela usando o comando INSERT INTO:
INSERT INTO Clientes (ClienteID, Nome, Email, DataNascimento)
VALUES (1, 'João Silva', 'joao.silva@email.com', '1990-05-15');

Explicação: INSERT INTO insere dados na tabela.
Os valores entre parênteses correspondem às colunas da tabela.

Passo 3: Consultando Dados
Agora, para consultar os dados que você inseriu na tabela, você usa o comando SELECT:
SELECT * FROM Clientes;

Explicação:SELECT *: seleciona todos os dados da tabela.
FROM Clientes: indica de qual tabela você quer buscar os dados.
Se você quiser consultar apenas alguns campos específicos, pode fazer assim:
SELECT Nome, Email FROM Clientes;

Passo 4: Atualizando Dados
Para atualizar dados existentes, você usa o comando UPDATE:
UPDATE Clientes
SET Email = 'novo.email@email.com'
WHERE ClienteID = 1;

Explicação:UPDATE: modifica dados existentes.
SET: define quais colunas e valores serão alterados.
WHERE: especifica quais linhas devem ser alteradas (se você não usar o WHERE, todos os registros serão atualizados).

Passo 5: Deletando Dados
Para excluir registros da tabela, você usa o comando DELETE:
DELETE FROM Clientes
WHERE ClienteID = 1;

Explicação: DELETE FROM: exclui dados de uma tabela.
WHERE: especifica qual registro deve ser excluído. Sem o WHERE, todos os registros seriam excluídos.

Passo 6: Filtrando Dados
Você pode filtrar dados usando a cláusula WHERE. Por exemplo, se você quiser ver todos os clientes que nasceram após 1º de janeiro de 1990:
SELECT * FROM Clientes
WHERE DataNascimento > '1990-01-01';

Passo 7: Ordenando Resultados
Para ordenar os resultados de uma consulta, você pode usar a cláusula ORDER BY:
SELECT * FROM Clientes
ORDER BY Nome ASC;  -- Ordena pelo nome em ordem crescente (ASC)

Se quiser ordenar em ordem decrescente (do Z ao A), pode usar DESC:
SELECT * FROM Clientes
ORDER BY Nome DESC;
_______________________________________________________________________________________________________________________________________________________________________

* RESTRIÇÕES DE COLUNA CONSTRAINT (CLÁUSULA CONSTRAINT)
- Restrições são regras pré-definidas impostas às colunas de uma tabela.
- Usadas para controlar os dados que são inseridos, em nível de coluna ou de tabela.
- Podem ser especificadas no momento de criação da tabela (CREATE) ou após a tabela ter sido criada (ALTER)

* Constraints no SQL Server:
- NOT NULL: Por padrão, o SQL Server permite armazenamento de valores nulos em colunas. A constraint NOT NULL impede que uma coluna aceite valores NULL. Deste modo, não é possível inserir um registro (ou atualizar) sem que haja um valor neste campo. Exemplo: Validade DATE NOT NULL
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- UNIQUE: Assegura que não haja valores duplicados em uma coluna ou combinação de colunas. Pode haver várias constraints UNIQUE em uma tabela, mas apenas uma Chave Primária por tabela. Uma constraint PRIMARY KEY automaticamente possui uma restrição UNIQUE definida. Exemplo: NomeProduto VARCHAR(50) NOT NULL UNIQUE
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- CHECK: Define um conjunto de valores válidos que podem ser inseridos em determinadas colunas. Se for definida em uma única coluna ela permitirá apenas determinados valores para a coluna. Usada para limitar os valores que podem ser colocados em uma coluna. Exemplo: PrecoProduto MONEY NOT NULL CHECK(PrecoProduto > 0)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- PRIMARY KEY: Uma chave primária identifica de forma única cada registro em uma tabela de banco de dados. A coluna não pode conter valores repetidos e nem valores NULL. Estabelece os relacionamentos entre tabelas. Cada tabela só pode ter uma única chave primária. Exemplo: CodProduto SMALLINT PRIMARY KEY
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- FOREIGN KEY: Cria relacionamentos entre tabelas, combinada com chaves primárias (relacionamento pai-filho). Cada registro em uma coluna de chave estrangeira da tabela-filha deve possuir um registro correspondente na chave primária (tabela-pai). Não pode possuir valores NULL. Impõe integridade referencial às tabelas.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- DEFAULT: Fornece um valor padrão para uma coluna. O valor padrão é inserido em uma coluna caso nenhum outro valor seja especificado durante a inserção de um novo registro. Usada para fornecer um valor padrão para uma coluna quando nenhum valor é especificado. Exemplo: CodFornecedor SMALLINT DEFAULT 1520
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

				
			* DEFRENÇAS ENTRE PRIMARY KEY e UNIQUE
+--------------------------+----------------------------------------------------------------+
|       Primary Key        |                          Unique                                |
+-------------------------+-----------------------------------------------------------------+
| Identifica cada linha de | Identifica valores únicos em uma coluna de uma tabela.         |
| forma única em uma       |                                                                |
| tabela.                  |                                                                |
+-------------------------+-----------------------------------------------------------------+
| Não podem haver valores  | Pode aceitar um valor NULL na coluna.                          |
| NULL.                    |                                                                |
+-------------------------+-----------------------------------------------------------------+
| Uma tabela somente pode  | Uma tabela pode ter mais de uma restrição unique.              |
| ter uma única chave      |                                                                |
| primária.                |                                                                |
+------------------------- +----------------------------------------------------------------+
| Um índice clusterizado   | Índices não-clusterizados são criados nas colunas.             |
| é criado por padrão.     |                                                                |
+-------------------------+---------------------------------------------------------------+

EXEMPLO DE CONSTRAINTS
CREATE TABLE Produtos(
   CodProduto SMALLINT PRIMARY KEY,
   NomeProduto VARCHAR(50) NOT NULL UNIQUE,
   CodFornecedor SMALLINT DEFAULT 1520,
   Validade DATE NOT NULL,
   PrecoProduto MONEY NOT NULL CHECK(PrecoProduto > 0),
   CONSTRAINT fk_id_fornecedor FOREIGN KEY (CodFornecedor) REFERENCES fornecedores (CodFornecedor) ON DELETE CASCADE
);

_______________________________________________________________________________________________________________________________________________________________________

* CRIAR TABELAS (CREATE TABLE): 
- Sintaxe básica:
CREATE TABLE NomeTabela(   
   coluna1 tipo1 restrições,
   coluna2 tipo2 restrições,

   ...

   colunaN tipo restrições,
   restrições adicionais
);

***OBS: Ao criar um banco de dados, devemos começar criando as tabelas que não têm campos dependentes de outras tabelas. Ou seja, crie primeiro as tabelas independentes, aquelas que não fazem referência a dados de outras tabelas.
- Primeiro criamos as tabelas que não tem chave estrangeira.
- Se possível sempre utilizar o menor tipo possível para economizar espaço no banco e em memória.
_______________________________________________________________________________________________________________________________________________________________________

* TIPOS DE DADOS
- char(n): String de caracteres e tamanho fixo n, máximo de 8000 caracteres.
- varchar(n): String de caracteres de tamanho variável n, máximo de 8000 caracteres.
- tinyint: Números inteiros de 0 a 255.
- smallint: Números inteiros de -32768 a 32767.
- int: Números inteiros entre -2, 147, 483, 648 e 2, 147, 483, 647.
- money: Dados monetários de -922.337.203.685.477,5808 até 922.337.203.685.477,5807.
- real: Números de ponto flutuante de precisão dupla entre -3,4 x 10³⁸ e 3,4 x 10³⁸.
- date: Data apenas. De 01/01/0001 a 31/12/9999.
- time: Hora apenas. Precisão de até 100 nanossegundos.

_______________________________________________________________________________________________________________________________________________________________________

OBS: Ao criar chaves estrangeiras, uma boa prática para facilitar o entendimento do relacionamento entre as tabelas no banco de dados é utilizar nomes de chaves estrangeiras que correspondam aos nomes dos IDs das tabelas relacionadas. Embora isso não seja uma obrigatoriedade, adotar essa convenção ajuda a tornar o esquema mais claro, pois torna explícito que a chave estrangeira faz referência à chave primária de outra tabela.
Além disso, os tipos de dados das chaves estrangeiras devem ser os mesmos ou compatíveis com os tipos de dados das chaves primárias das tabelas que possuem relacionamento. Isso garante a integridade referencial e melhora a performance do banco de dados.

Exemplo:
Vamos supor que temos duas tabelas: Clientes e Pedidos. Cada pedido deve estar associado a um cliente, então criamos uma chave estrangeira na tabela Pedidos que faz referência à chave primária da tabela Clientes.

1. Criação da Tabela Clientes:
CREATE TABLE Clientes (
    ClienteId INT PRIMARY KEY,  -- Chave primária da tabela Clientes
    Nome VARCHAR(100),
    Email VARCHAR(100)
);


2. Criação da Tabela Pedidos:
CREATE TABLE Pedidos (
    PedidoId INT PRIMARY KEY,  -- Chave primária da tabela Pedidos
    DataPedido DATE,
    ClienteId INT,  -- Chave estrangeira que referencia o ClienteId de Clientes
    FOREIGN KEY (ClienteId) REFERENCES Clientes(ClienteId)
);


Explicação sobre os tipos de dados:
Chave Primária (ClienteId em Clientes): A coluna ClienteId em Clientes é definida como INT, o que significa que ela pode armazenar valores inteiros.
Chave Estrangeira (ClienteId em Pedidos): A chave estrangeira ClienteId na tabela Pedidos também deve ser do tipo INT para garantir que ela seja compatível com a chave primária da tabela Clientes.
Ao utilizar o mesmo tipo de dados para a chave primária e a chave estrangeira, o banco de dados pode garantir que os valores armazenados em Pedidos.ClienteId correspondam corretamente aos valores em Clientes.ClienteId, assegurando a integridade referencial. Isso significa que um valor em Pedidos.ClienteId só pode ser inserido se já existir um correspondente valor em Clientes.ClienteId.

Importância de Usar Tipos de Dados Compatíveis:
Integridade Referencial: Quando os tipos de dados são os mesmos, o banco de dados pode garantir que os valores nas chaves estrangeiras sempre correspondam aos valores das chaves primárias. Caso contrário, você poderia inserir um valor incompatível, violando o relacionamento.

Desempenho: O banco de dados pode otimizar buscas e comparações de valores quando as colunas de relacionamento têm tipos de dados compatíveis. Isso melhora a performance em consultas e operações de junção (JOIN).

Exemplo de erro se os tipos de dados não forem compatíveis:
Se, por exemplo, a chave primária ClienteId fosse definida como BIGINT na tabela Clientes, mas a chave estrangeira na tabela Pedidos fosse definida como INT, o banco de dados geraria um erro de incompatibilidade de tipos quando tentasse associar as duas tabelas. Para corrigir, seria necessário ajustar o tipo de dados da chave estrangeira para BIGINT.

Conclusão:
Nomes Consistentes: Utilizar o mesmo nome para a chave primária e a chave estrangeira, como ClienteId em ambos os casos, facilita o entendimento de que há uma relação entre as tabelas.
Tipos de Dados Compatíveis: É importante que as chaves primárias e estrangeiras tenham tipos de dados compatíveis (por exemplo, ambos INT ou ambos BIGINT) para garantir a integridade referencial e desempenho eficiente nas operações do banco de dados.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*SINTAXE PARA CRIAÇÃODE CHAVE ESTRANGEIRA:
Sintaxe geral
Aqui está a estrutura básica para adicionar uma chave estrangeira em SQL:

CONSTRAINT nome_da_restricao FOREIGN KEY (campo_da_tabela_atual)
REFERENCES tabela_referenciada(campo_referenciado)
[ON DELETE CASCADE] [ON UPDATE CASCADE];

------------------------------------------------------------------------------------------------------------------------------------------------------------------------Explicando o exemplo:

- CONSTRAINT nome_da_restricao: Define o nome da restrição (restrição de chave estrangeira).

- FOREIGN KEY (campo_da_tabela_atual): Especifica o campo da tabela atual que se tornará a chave estrangeira.

- REFERENCES tabela_referenciada(campo_referenciado): Indica qual é a tabela de referência (que já tem a chave primária) e o campo que é a chave primária nessa tabela.

- ON DELETE CASCADE (opcional): Define o que deve acontecer quando um registro na tabela referenciada for excluído. "CASCADE" significa que todos os registros dependentes (da tabela atual) também serão excluídos automaticamente.

- ON UPDATE CASCADE (opcional): Define o que deve acontecer quando um valor na chave primária da tabela referenciada for atualizado. "CASCADE" significa que os valores correspondentes nas tabelas dependentes também serão atualizados automaticamente.

_______________________________________________________________________________________________________________________________________________________________________
O QUE É UMA TABELA ASSOCIATIVA?
Uma tabela associativa (ou de relacionamento) é utilizada para estabelecer um relacionamento muitos-para-muitos entre duas outras tabelas. No caso, a tabela LivroAutor está relacionando os livros com seus autores, permitindo que um livro tenha vários autores e um autor possa escrever vários livros.

No caso do seu código:

-- Tabela associativa que armazena os relacionamentos entre livros e autores
CREATE TABLE LivroAutor (
    IdLivro SMALLINT NOT NULL,  -- Referência à tabela Livro
    IdAutor SMALLINT NOT NULL,  -- Referência à tabela Autor
    CONSTRAINT fk_id_livros FOREIGN KEY(IdLivro) REFERENCES Livro(IdLivro),
    CONSTRAINT fk_id_Autor FOREIGN KEY(IdAutor) REFERENCES Autor(IdAutor)
);

_______________________________________________________________________________________________________________________________________________________________________

* GERENCIAR TABELAS - ALTER, DROP, RENAME: 


































