							CURSO DE SQL COM SQL SERVER BÓSON TREINAMENTOS

O SQL (Structured Query Language) é a linguagem padrão usada para interagir com bancos de dados relacionais, e o SQL Server é um dos sistemas de gerenciamento de banco de dados mais populares da Microsoft.

Passo 1: Criando uma Tabela
A criação de uma tabela é a primeira coisa que você faz ao configurar um banco de dados. Vamos criar uma tabela simples para armazenar informações de clientes:

CREATE TABLE Clientes (
    ClienteID INT PRIMARY KEY,       -- Identificador único para cada cliente
    Nome NVARCHAR(100),              -- Nome do cliente
    Email NVARCHAR(100),             -- E-mail do cliente
    DataNascimento DATE              -- Data de nascimento do cliente
);

Explicação:
CREATE TABLE: cria uma nova tabela no banco de dados.
INT: tipo de dado para números inteiros.
NVARCHAR(100): tipo de dado para texto (strings) com até 100 caracteres.
PRIMARY KEY: define que a coluna ClienteID será a chave primária, ou seja, cada valor nela deve ser único.

Passo 2: Inserindo Dados
Depois de criar a tabela, você pode inserir dados nela usando o comando INSERT INTO:
INSERT INTO Clientes (ClienteID, Nome, Email, DataNascimento)
VALUES (1, 'João Silva', 'joao.silva@email.com', '1990-05-15');

Explicação: INSERT INTO insere dados na tabela.
Os valores entre parênteses correspondem às colunas da tabela.

Passo 3: Consultando Dados
Agora, para consultar os dados que você inseriu na tabela, você usa o comando SELECT:
SELECT * FROM Clientes;

Explicação:SELECT *: seleciona todos os dados da tabela.
FROM Clientes: indica de qual tabela você quer buscar os dados.
Se você quiser consultar apenas alguns campos específicos, pode fazer assim:
SELECT Nome, Email FROM Clientes;

Passo 4: Atualizando Dados
Para atualizar dados existentes, você usa o comando UPDATE:
UPDATE Clientes
SET Email = 'novo.email@email.com'
WHERE ClienteID = 1;

Explicação:UPDATE: modifica dados existentes.
SET: define quais colunas e valores serão alterados.
WHERE: especifica quais linhas devem ser alteradas (se você não usar o WHERE, todos os registros serão atualizados).

Passo 5: Deletando Dados
Para excluir registros da tabela, você usa o comando DELETE:
DELETE FROM Clientes
WHERE ClienteID = 1;

Explicação: DELETE FROM: exclui dados de uma tabela.
WHERE: especifica qual registro deve ser excluído. Sem o WHERE, todos os registros seriam excluídos.

Passo 6: Filtrando Dados
Você pode filtrar dados usando a cláusula WHERE. Por exemplo, se você quiser ver todos os clientes que nasceram após 1º de janeiro de 1990:
SELECT * FROM Clientes
WHERE DataNascimento > '1990-01-01';

Passo 7: Ordenando Resultados
Para ordenar os resultados de uma consulta, você pode usar a cláusula ORDER BY:
SELECT * FROM Clientes
ORDER BY Nome ASC;  -- Ordena pelo nome em ordem crescente (ASC)

Se quiser ordenar em ordem decrescente (do Z ao A), pode usar DESC:
SELECT * FROM Clientes
ORDER BY Nome DESC;
_______________________________________________________________________________________________________________________________________________________________________

* RESTRIÇÕES DE COLUNA CONSTRAINT (CLÁUSULA CONSTRAINT)
- Restrições são regras pré-definidas impostas às colunas de uma tabela.
- Usadas para controlar os dados que são inseridos, em nível de coluna ou de tabela.
- Podem ser especificadas no momento de criação da tabela (CREATE) ou após a tabela ter sido criada (ALTER)

* Constraints no SQL Server:
- NOT NULL: Por padrão, o SQL Server permite armazenamento de valores nulos em colunas. A constraint NOT NULL impede que uma coluna aceite valores NULL. Deste modo, não é possível inserir um registro (ou atualizar) sem que haja um valor neste campo. Exemplo: Validade DATE NOT NULL
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- UNIQUE: Assegura que não haja valores duplicados em uma coluna ou combinação de colunas. Pode haver várias constraints UNIQUE em uma tabela, mas apenas uma Chave Primária por tabela. Uma constraint PRIMARY KEY automaticamente possui uma restrição UNIQUE definida. Exemplo: NomeProduto VARCHAR(50) NOT NULL UNIQUE
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- CHECK: Define um conjunto de valores válidos que podem ser inseridos em determinadas colunas. Se for definida em uma única coluna ela permitirá apenas determinados valores para a coluna. Usada para limitar os valores que podem ser colocados em uma coluna. Exemplo: PrecoProduto MONEY NOT NULL CHECK(PrecoProduto > 0)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- PRIMARY KEY: Uma chave primária identifica de forma única cada registro em uma tabela de banco de dados. A coluna não pode conter valores repetidos e nem valores NULL. Estabelece os relacionamentos entre tabelas. Cada tabela só pode ter uma única chave primária. Exemplo: CodProduto SMALLINT PRIMARY KEY
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- FOREIGN KEY: Cria relacionamentos entre tabelas, combinada com chaves primárias (relacionamento pai-filho). Cada registro em uma coluna de chave estrangeira da tabela-filha deve possuir um registro correspondente na chave primária (tabela-pai). Não pode possuir valores NULL. Impõe integridade referencial às tabelas.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- DEFAULT: Fornece um valor padrão para uma coluna. O valor padrão é inserido em uma coluna caso nenhum outro valor seja especificado durante a inserção de um novo registro. Usada para fornecer um valor padrão para uma coluna quando nenhum valor é especificado. Exemplo: CodFornecedor SMALLINT DEFAULT 1520
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

				
			* DEFRENÇAS ENTRE PRIMARY KEY e UNIQUE
+--------------------------+----------------------------------------------------------------+
|       Primary Key        |                          Unique                                |
+-------------------------+-----------------------------------------------------------------+
| Identifica cada linha de | Identifica valores únicos em uma coluna de uma tabela.         |
| forma única em uma       |                                                                |
| tabela.                  |                                                                |
+-------------------------+-----------------------------------------------------------------+
| Não podem haver valores  | Pode aceitar um valor NULL na coluna.                          |
| NULL.                    |                                                                |
+-------------------------+-----------------------------------------------------------------+
| Uma tabela somente pode  | Uma tabela pode ter mais de uma restrição unique.              |
| ter uma única chave      |                                                                |
| primária.                |                                                                |
+------------------------- +----------------------------------------------------------------+
| Um índice clusterizado   | Índices não-clusterizados são criados nas colunas.             |
| é criado por padrão.     |                                                                |
+-------------------------+---------------------------------------------------------------+

EXEMPLO DE CONSTRAINTS
CREATE TABLE Produtos(
   CodProduto SMALLINT PRIMARY KEY,
   NomeProduto VARCHAR(50) NOT NULL UNIQUE,
   CodFornecedor SMALLINT DEFAULT 1520,
   Validade DATE NOT NULL,
   PrecoProduto MONEY NOT NULL CHECK(PrecoProduto > 0),
   CONSTRAINT fk_id_fornecedor FOREIGN KEY (CodFornecedor) REFERENCES fornecedores (CodFornecedor) ON DELETE CASCADE
);

_______________________________________________________________________________________________________________________________________________________________________

* CRIAR TABELAS (CREATE TABLE): 
- Sintaxe básica:
CREATE TABLE NomeTabela(   
   coluna1 tipo1 restrições,
   coluna2 tipo2 restrições,

   ...

   colunaN tipo restrições,
   restrições adicionais
);

***OBS: Ao criar um banco de dados, devemos começar criando as tabelas que não têm campos dependentes de outras tabelas. Ou seja, crie primeiro as tabelas independentes, aquelas que não fazem referência a dados de outras tabelas.
- Primeiro criamos as tabelas que não tem chave estrangeira.
- Se possível sempre utilizar o menor tipo possível para economizar espaço no banco e em memória.
_______________________________________________________________________________________________________________________________________________________________________

* TIPOS DE DADOS
- char(n): String de caracteres e tamanho fixo n, máximo de 8000 caracteres.
- varchar(n): String de caracteres de tamanho variável n, máximo de 8000 caracteres.
- tinyint: Números inteiros de 0 a 255.
- smallint: Números inteiros de -32768 a 32767.
- int: Números inteiros entre -2, 147, 483, 648 e 2, 147, 483, 647.
- money: Dados monetários de -922.337.203.685.477,5808 até 922.337.203.685.477,5807.
- real: Números de ponto flutuante de precisão dupla entre -3,4 x 10³⁸ e 3,4 x 10³⁸.
- date: Data apenas. De 01/01/0001 a 31/12/9999.
- time: Hora apenas. Precisão de até 100 nanossegundos.

_______________________________________________________________________________________________________________________________________________________________________

OBS: Ao criar chaves estrangeiras, uma boa prática para facilitar o entendimento do relacionamento entre as tabelas no banco de dados é utilizar nomes de chaves estrangeiras que correspondam aos nomes dos IDs das tabelas relacionadas. Embora isso não seja uma obrigatoriedade, adotar essa convenção ajuda a tornar o esquema mais claro, pois torna explícito que a chave estrangeira faz referência à chave primária de outra tabela.
Além disso, os tipos de dados das chaves estrangeiras devem ser os mesmos ou compatíveis com os tipos de dados das chaves primárias das tabelas que possuem relacionamento. Isso garante a integridade referencial e melhora a performance do banco de dados.

Exemplo:
Vamos supor que temos duas tabelas: Clientes e Pedidos. Cada pedido deve estar associado a um cliente, então criamos uma chave estrangeira na tabela Pedidos que faz referência à chave primária da tabela Clientes.

1. Criação da Tabela Clientes:
CREATE TABLE Clientes (
    ClienteId INT PRIMARY KEY,  -- Chave primária da tabela Clientes
    Nome VARCHAR(100),
    Email VARCHAR(100)
);


2. Criação da Tabela Pedidos:
CREATE TABLE Pedidos (
    PedidoId INT PRIMARY KEY,  -- Chave primária da tabela Pedidos
    DataPedido DATE,
    ClienteId INT,  -- Chave estrangeira que referencia o ClienteId de Clientes
    FOREIGN KEY (ClienteId) REFERENCES Clientes(ClienteId)
);


Explicação sobre os tipos de dados:
Chave Primária (ClienteId em Clientes): A coluna ClienteId em Clientes é definida como INT, o que significa que ela pode armazenar valores inteiros.
Chave Estrangeira (ClienteId em Pedidos): A chave estrangeira ClienteId na tabela Pedidos também deve ser do tipo INT para garantir que ela seja compatível com a chave primária da tabela Clientes.
Ao utilizar o mesmo tipo de dados para a chave primária e a chave estrangeira, o banco de dados pode garantir que os valores armazenados em Pedidos.ClienteId correspondam corretamente aos valores em Clientes.ClienteId, assegurando a integridade referencial. Isso significa que um valor em Pedidos.ClienteId só pode ser inserido se já existir um correspondente valor em Clientes.ClienteId.

Importância de Usar Tipos de Dados Compatíveis:
Integridade Referencial: Quando os tipos de dados são os mesmos, o banco de dados pode garantir que os valores nas chaves estrangeiras sempre correspondam aos valores das chaves primárias. Caso contrário, você poderia inserir um valor incompatível, violando o relacionamento.

Desempenho: O banco de dados pode otimizar buscas e comparações de valores quando as colunas de relacionamento têm tipos de dados compatíveis. Isso melhora a performance em consultas e operações de junção (JOIN).

Exemplo de erro se os tipos de dados não forem compatíveis:
Se, por exemplo, a chave primária ClienteId fosse definida como BIGINT na tabela Clientes, mas a chave estrangeira na tabela Pedidos fosse definida como INT, o banco de dados geraria um erro de incompatibilidade de tipos quando tentasse associar as duas tabelas. Para corrigir, seria necessário ajustar o tipo de dados da chave estrangeira para BIGINT.

Conclusão:
Nomes Consistentes: Utilizar o mesmo nome para a chave primária e a chave estrangeira, como ClienteId em ambos os casos, facilita o entendimento de que há uma relação entre as tabelas.
Tipos de Dados Compatíveis: É importante que as chaves primárias e estrangeiras tenham tipos de dados compatíveis (por exemplo, ambos INT ou ambos BIGINT) para garantir a integridade referencial e desempenho eficiente nas operações do banco de dados.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*SINTAXE PARA CRIAÇÃODE CHAVE ESTRANGEIRA:
Sintaxe geral
Aqui está a estrutura básica para adicionar uma chave estrangeira em SQL:

CONSTRAINT nome_da_restricao FOREIGN KEY (campo_da_tabela_atual)
REFERENCES tabela_referenciada(campo_referenciado)
[ON DELETE CASCADE] [ON UPDATE CASCADE];

------------------------------------------------------------------------------------------------------------------------------------------------------------------------Explicando o exemplo:

- CONSTRAINT nome_da_restricao: Define o nome da restrição (restrição de chave estrangeira).

- FOREIGN KEY (campo_da_tabela_atual): Especifica o campo da tabela atual que se tornará a chave estrangeira.

- REFERENCES tabela_referenciada(campo_referenciado): Indica qual é a tabela de referência (que já tem a chave primária) e o campo que é a chave primária nessa tabela.

- ON DELETE CASCADE (opcional): Define o que deve acontecer quando um registro na tabela referenciada for excluído. "CASCADE" significa que todos os registros dependentes (da tabela atual) também serão excluídos automaticamente.

- ON UPDATE CASCADE (opcional): Define o que deve acontecer quando um valor na chave primária da tabela referenciada for atualizado. "CASCADE" significa que os valores correspondentes nas tabelas dependentes também serão atualizados automaticamente.

_______________________________________________________________________________________________________________________________________________________________________
O QUE É UMA TABELA ASSOCIATIVA?
Uma tabela associativa (ou de relacionamento) é utilizada para estabelecer um relacionamento muitos-para-muitos entre duas outras tabelas. No caso, a tabela LivroAutor está relacionando os livros com seus autores, permitindo que um livro tenha vários autores e um autor possa escrever vários livros.

No caso do seu código:

-- Tabela associativa que armazena os relacionamentos entre livros e autores
CREATE TABLE LivroAutor (
    IdLivro SMALLINT NOT NULL,  -- Referência à tabela Livro
    IdAutor SMALLINT NOT NULL,  -- Referência à tabela Autor
    CONSTRAINT fk_id_livros FOREIGN KEY(IdLivro) REFERENCES Livro(IdLivro),
    CONSTRAINT fk_id_Autor FOREIGN KEY(IdAutor) REFERENCES Autor(IdAutor)
);

_______________________________________________________________________________________________________________________________________________________________________

* GERENCIAMENTO TABELAS - ALTER, DROP, RENAME: No SQL Server, o gerenciamento de tabelas envolve a utilização de comandos para modificar a estrutura das tabelas no banco de dados. Os comandos ALTER, DROP e RENAME são utilizados para realizar essas modificações. Vamos explicar cada um deles:

1. ALTER TABLE
O comando ALTER TABLE é usado para modificar a estrutura de uma tabela existente. Ele permite que você adicione, exclua ou altere colunas de uma tabela. Aqui estão alguns exemplos:

Adicionar uma nova coluna:
ALTER TABLE nome_da_tabela
ADD nova_coluna tipo_de_dado;

Exemplo:
ALTER TABLE Funcionarios
ADD DataDeNascimento DATE;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Modificar uma coluna existente:
ALTER TABLE nome_da_tabela
ALTER COLUMN nome_da_coluna novo_tipo_de_dado;

Exemplo:
ALTER TABLE Funcionarios
ALTER COLUMN Salario DECIMAL(10, 2);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Excluir uma coluna:
ALTER TABLE nome_da_tabela
DROP COLUMN nome_da_coluna;

Exemplo:
ALTER TABLE Funcionarios
DROP COLUMN DataDeNascimento;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. DROP TABLE
O comando DROP TABLE é utilizado para excluir completamente uma tabela do banco de dados, junto com todos os dados nela contidos. Tenha muito cuidado ao usar esse comando, pois ele é irreversível.
DROP TABLE nome_da_tabela;

Exemplo:
DROP TABLE Funcionarios;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. RENAME (ALTER TABLE para renomear)
No SQL Server, o comando RENAME não é diretamente suportado. Para renomear uma tabela, você usa o comando sp_rename. Este procedimento armazenado é utilizado para alterar o nome de objetos no banco de dados, como tabelas, colunas, índices, etc.

Para renomear uma tabela:
EXEC sp_rename 'nome_antigo_da_tabela', 'novo_nome_da_tabela';

Exemplo:
EXEC sp_rename 'Funcionarios', 'Empregados';
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Para renomear uma coluna:
EXEC sp_rename 'nome_da_tabela.nome_da_coluna', 'novo_nome_da_coluna', 'COLUMN';

Exemplo:
EXEC sp_rename 'Empregados.Salario', 'Rendimento', 'COLUMN';
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Resumo:
ALTER TABLE: Modifica a estrutura da tabela, como adicionar, excluir ou alterar colunas.
DROP TABLE: Exclui a tabela e seus dados permanentemente.
RENAME: No SQL Server, usa-se sp_rename para renomear tabelas e colunas.

_______________________________________________________________________________________________________________________________________________________________________

Complementos sobre o código e os comandos:
1. Adicionando uma chave primária
Quando você usa o comando ALTER TABLE para adicionar uma chave primária à tabela, é importante observar que ela só pode ser adicionada se a tabela não tiver uma chave primária definida previamente.

Exemplo de código:
ALTER TABLE NomeTabela
ADD PRIMARY KEY (Coluna);

Isso cria uma chave primária na coluna especificada, garantindo que os valores nesta coluna sejam únicos e não nulos.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Excluir uma constraint de uma coluna
As constraints (restrições) em SQL são usadas para impor regras sobre os dados em uma tabela, como PRIMARY KEY, FOREIGN KEY, CHECK, UNIQUE, etc. Para remover uma constraint de uma tabela, você deve usar o comando DROP CONSTRAINT.

Exemplo:
ALTER TABLE NomeTabela
DROP CONSTRAINT NomeConstraint;
Isso remove a constraint especificada, que pode ser, por exemplo, uma chave primária ou uma chave estrangeira.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Verificar o nome das constraints de uma tabela
Você pode usar o procedimento armazenado sp_help para listar todas as propriedades de uma tabela, incluindo as constraints associadas a ela. Isso pode ser útil para saber quais constraints você pode querer alterar ou remover.

Exemplo:
sp_help Livro;
Este comando retornará uma série de informações sobre a tabela Livro, incluindo as constraints que ela possui.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Exclusão de coluna
Ao excluir uma coluna, é importante lembrar que todos os dados daquela coluna serão apagados. O comando ALTER TABLE ... DROP COLUMN permite remover uma coluna específica de uma tabela.

Exemplo:
ALTER TABLE Livro
DROP COLUMN Edição;
Este comando remove a coluna Edição da tabela Livro.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Resumo do código complementado:
Adicionar uma nova coluna: Usa-se ALTER TABLE seguido de ADD para adicionar uma coluna a uma tabela existente.

Alterar tipo de dado de uma coluna: Com o ALTER COLUMN, é possível modificar o tipo de dado de uma coluna existente.

Adicionar uma chave primária: Você pode definir uma chave primária com ADD PRIMARY KEY, desde que a tabela não tenha uma chave primária existente.

Remover uma constraint: Para excluir uma constraint, usa-se o comando DROP CONSTRAINT.

Verificar informações sobre a tabela e constraints: A função sp_help fornece detalhes sobre as propriedades de uma tabela, incluindo suas constraints.

Excluir uma coluna de uma tabela: Utiliza-se DROP COLUMN para remover uma coluna de uma tabela.

Excluir uma tabela: Com o comando DROP TABLE, a tabela inteira é excluída permanentemente.

Esses detalhes adicionais ajudam a fornecer uma visão mais completa do gerenciamento de tabelas no SQL Server, especialmente quando se trata de manipulação de constraints e chaves.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Renomear objetos no SQL Server (usando sp_rename)
No SQL Server, não existe um comando direto chamado RENAME como em alguns outros SGBDs (Sistema de Gerenciamento de Banco de Dados). Em vez disso, para renomear tabelas, colunas, índices, e outros objetos do banco de dados, usamos o procedimento armazenado sp_rename.

Sintaxe básica:
EXEC sp_rename 'nome_atual', 'novo_nome';
Esse comando pode ser usado para renomear tabelas, colunas, e até índices.

Exemplos práticos de uso de sp_rename:
1. Renomear uma tabela
Se você quiser alterar o nome de uma tabela, basta fornecer o nome atual e o novo nome desejado.

Exemplo:
EXEC sp_rename 'Livro', 'Livros';
Isso renomeia a tabela Livro para Livros.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Renomear uma coluna
Para renomear uma coluna de uma tabela, a sintaxe é ligeiramente diferente. Você precisa especificar o nome da tabela, o nome da coluna que você quer renomear, e o novo nome da coluna.

Exemplo:
EXEC sp_rename 'Livros.Edição', 'Versao', 'COLUMN';
Aqui, a coluna Edição da tabela Livros é renomeada para Versao.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. Renomear um índice
Da mesma forma, você pode usar o sp_rename para alterar o nome de um índice.

Exemplo:
EXEC sp_rename 'Livros.Index_Edicao', 'Index_Versao', 'INDEX';
Isso renomeia o índice Index_Edicao para Index_Versao na tabela Livros.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Considerações importantes:
Necessidade de permissões: Para usar o sp_rename, o usuário precisa ter permissões adequadas no banco de dados, como permissão de ALTER em tabelas ou objetos a serem renomeados.

Impacto nas dependências: Renomear objetos, como tabelas ou colunas, pode afetar dependências (como views, stored procedures, triggers, etc.) que referenciam esses objetos. É importante revisar essas dependências e atualizá-las conforme necessário após renomear.

Limitações do sp_rename:

O sp_rename não pode ser utilizado para renomear objetos do tipo constraint diretamente. Para isso, é necessário excluir a constraint e criar uma nova.
Não é possível renomear uma chave primária ou chave estrangeira diretamente; é necessário removê-las e criá-las novamente com o novo nome.

Resumo:
No SQL Server, o comando RENAME é substituído pelo procedimento armazenado sp_rename.
sp_rename pode ser usado para renomear tabelas, colunas, índices e outros objetos.
Ao usar sp_rename, sempre esteja atento às dependências do objeto renomeado para evitar problemas no banco de dados.
Agora, o conjunto completo de operações sobre gerenciamento de tabelas fica assim:

ALTER TABLE: Modifica a estrutura de tabelas, como adicionar ou excluir colunas, alterar tipos de dados, ou adicionar/remover constraints.
DROP TABLE: Exclui completamente uma tabela e seus dados.
RENAME (via sp_rename): Renomeia tabelas, colunas, índices e outros objetos no banco de dados.
_______________________________________________________________________________________________________________________________________________________________________

* CADASTRAR DADOS - INSERT INTO(Inserir Dados): Inserir um registro(linha) em uma tabela.
Sintaxe:
INSERT INTO tabela(coluna1, coluna2, ...) VALUES(valor1, valor2, ...);
_______________________________________________________________________________________________________________________________________________________________________

**OBS: Na hora de inserir os dados nas tabelas, deve-se primeiramente inserir os dados nas tabelas que não dependem de nenhuma outra, ou seja que não tenha chave estrangeira.































